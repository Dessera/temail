# IMAP

因为`_resp_lock`的存在，所有的响应都是按顺序解析并推入结果队列的，并且，这些响应的handler遵守着一对一的规则，并且在请求发送前就已被推入，所以我们不必担心错位。

因为发送请求可能失败，这时要把推入的`resp`弹出来，如果我们允许请求的并发，就会导致可能弹出错误的响应，因此使用`_request_lock`确保同时只能发送一个请求。

此二者保证了同一时刻只能有一个线程操控请求处理队列，但我们可以同时处理请求和响应的剩余部分。

结果队列的读写是一个很复杂的行为，但我们要明确一点，可以有多个线程监听ready_read信号，但不允许这些线程同时读我们的缓冲区（因为一个ready_read只产生一个数据）！

所以，我们的结果队列最多只有一个线程在读，一个线程在写，在Block模式下，即使不加锁也不会产生问题，但在Queue模式下，可能会造成多线程读写，所以我们添加一个_read_lock在读写时上锁。

另外一提，wait_for系列函数完全不支持多线程，因为使用这套读写方法需要三步骤：

- request
- wait
- read

这三个行为是用户控制的，在任何一步发生了切换都会导致等到的信号和读到的数据不一致的情况，因此该组api仅支持简单的同步调用。

但是情况在错误处理时又会变得不一样，错误是可以被所有人读的，并且，我们上面提到的请求和响应处理都可以设置错误，我们现在有多个读者和多个写者！这个时候用信号做处理是完全做不到保证读写的一致性的（不会造成破坏，但可能造成数据的错漏），我们的解决方法是直接把参数传递给error_occurred，这样我们的信号参数和我们存储的错误是没有关系的，

另外，同样地，error error_string 和 reset_error 也无法在多线程中使用，错误信息会在wait类函数时被使用（判断请求是否出错），这些函数无法处理并发问题。
